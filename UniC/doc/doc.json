{
    "name": "./",
    "subfolders": [
        {
            "name": "./Algorithms",
            "subfolders": [
                {
                    "name": "./Algorithms/Search",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Algorithms/Search/Search.c",
                            "functions": []
                        }
                    ]
                },
                {
                    "name": "./Algorithms/Sort",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Algorithms/Sort/Sorting.c",
                            "functions": [
                                {
                                    "doc": "/**\n * @brief swaps two generics\n */",
                                    "header": "static void\tswap(Generic *a, Generic *b)",
                                    "body": "{\n\tGeneric\ttemp;\n\n\ttemp = *a;\n\t*a = *b;\n\t*b = temp;\n}"
                                },
                                {
                                    "doc": "/**\n * @brief merge sort recursive aux funcion \n */",
                                    "header": "void\tMergeSort_rec(Generic *arr, size_t low, size_t high, Comparator cmp)",
                                    "body": "{\n\tsize_t\tmid;\n\n\t// low < high when there are at least 2 elements\n\tif (low >= high)\n\t\treturn ;\n\tmid = (low + high) / 2;\n\tMergeSort_rec(arr, low, mid, cmp);\n\tMergeSort_rec(arr, mid + 1, high, cmp);\n\tMerge(arr, low, mid, high, cmp);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief merge sort\n * @param array\n * @param size\n * @param cmp\n */",
                                    "header": "void\tMergeSort(Generic *array, size_t size, Comparator cmp)",
                                    "body": "{\n\tMergeSort_rec(array, 0, size - 1, cmp);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief quick sort\n */",
                                    "header": "void\tQuickSort(int *array, size_t size)",
                                    "body": "{\n\tQuickSort_rec(array, 0, size - 1);\n}"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./libft",
            "subfolders": [],
            "files": [
                {
                    "name": "./libft/ft_atoi.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "static int\tft_is_sign(int c)",
                            "body": "{\n\treturn (c == '+' || c == '-');\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strdup.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_strjoin.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_tolower.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_tolower(int c)",
                            "body": "{\n\tif (c >= 'A' && c <= 'Z')\n\t\treturn (c + ('a' - 'A'));\n\treturn (c);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_itoa.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tint_len(int n, size_t iter)",
                            "body": "{\n\tif (!n && !iter)\n\t\treturn (1);\n\tif (!n)\n\t\treturn (0);\n\treturn (1 + int_len(n / 10, iter + 1));\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strtrim.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_calloc.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_isalpha.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isalpha(int c)",
                            "body": "{\n\tint\tisupper;\n\tint\tislower;\n\n\tisupper = (c >= 'A' && c <= 'Z');\n\tislower = (c >= 'a' && c <= 'z');\n\treturn (isupper || islower);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_bzero.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_bzero(void *b, size_t n)",
                            "body": "{\n\tft_memset(b, 0, n);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_striteri.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_striteri(char *s, void (*f)(unsigned int, char *))",
                            "body": "{\n\tunsigned int\ti;\n\n\tif (!s)\n\t\treturn ;\n\ti = 0;\n\twhile (*s && f)\n\t\tf(i++, s++);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strlcpy.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_strmapi.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_split.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_strchr.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_memset.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_isascii.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isascii(int c)",
                            "body": "{\n\treturn (c >= 0 && c <= 127);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_putstr_fd.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putstr_fd(char *s, int fd)",
                            "body": "{\n\tif (!s)\n\t\treturn ;\n\twrite(fd, s, ft_strlen(s));\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strlen.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tft_strlen(const char *s)",
                            "body": "{\n\tsize_t\tc;\n\n\tc = 0;\n\twhile (*(s++))\n\t\tc++;\n\treturn (c);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strrchr.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_isalnum.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isalnum(int c)",
                            "body": "{\n\tint\tischar;\n\tint\tisnum;\n\n\tischar = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n\tisnum = c >= '0' && c <= '9';\n\treturn (ischar || isnum);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strncmp.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_memchr.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_memcmp.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_substr.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_isdigit.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isdigit(int c)",
                            "body": "{\n\treturn (c >= '0' && c <= '9');\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_putendl_fd.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putendl_fd(char *s, int fd)",
                            "body": "{\n\tif (!s)\n\t\treturn ;\n\twrite(fd, s, ft_strlen(s));\n\twrite(fd, \"\\n\", 1);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_memmove.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_putchar_fd.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putchar_fd(char c, int fd)",
                            "body": "{\n\twrite(fd, &c, 1);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strnstr.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "char\tft_starts_with(const char *s, const char *sub)",
                            "body": "{\n\treturn (ft_strncmp(s, sub, ft_strlen(sub)) == 0);\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_strfjoin.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_putnbr_fd.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_strlcat.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_isprint.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isprint(int c)",
                            "body": "{\n\treturn (c >= ' ' && c <= '~');\n}"
                        }
                    ]
                },
                {
                    "name": "./libft/ft_memcpy.c",
                    "functions": []
                },
                {
                    "name": "./libft/ft_toupper.c",
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_toupper(int c)",
                            "body": "{\n\tif (c >= 'a' && c <= 'z')\n\t\treturn (c - ('a' - 'A'));\n\treturn (c);\n}"
                        }
                    ]
                }
            ]
        },
        {
            "name": "./Utils",
            "subfolders": [
                {
                    "name": "./Utils/Logging",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/Logging/Logging.c",
                            "functions": []
                        }
                    ]
                },
                {
                    "name": "./Utils/Compare",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/Compare/comparators.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "int\tCompare_String(Generic a, Generic b)",
                                    "body": "{\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\treturn (strcmp((char *)a, (char *)b));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tCompare_Int(Generic a, Generic b)",
                                    "body": "{\n\tint x;\n\tint y;\n\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\tx = *(int *)a;\n\ty = *(int *)b;\n\tif (x == y)\n\t\treturn (0);\n\tif (x < y)\n\t\treturn (-1);\n\treturn (1);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tCompare_Uint64(Generic a, Generic b)",
                                    "body": "{\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\treturn (*(uint64_t *)a - *(uint64_t *)b);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Conversion",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/Conversion/Conversion.c",
                            "functions": []
                        }
                    ]
                },
                {
                    "name": "./Utils/Hashing",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/Hashing/HashFunctions.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "define MAGIC 0xdeadbeef\n\nstatic size_t\tnormalize(size_t bytes, size_t size)",
                                    "body": "{\n\treturn (bytes % size);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_int(Generic key, size_t size)",
                                    "body": "{\n\treturn (hash_generic((size_t)key, size));\n}"
                                },
                                {
                                    "doc": "/**\n * @brief\n *\n * @param bytes anything\n * @param size hashmap size\n * @return size_t\n */",
                                    "header": "size_t\thash_generic(size_t bytes, size_t size)",
                                    "body": "{\n\tsize_t\tbin;\n\n\tbin = (size_t)bytes;\n\tbin = bin ^ (bin >> 4);\n\tbin = (bin + (bin << 5)) ^ MAGIC;\n\tbin = bin ^ (bin >> 11);\n\treturn (normalize((size_t)bin, size));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_universal(size_t key, uint64_t a, uint64_t b, uint64_t p,\n\t\tsize_t size)",
                                    "body": "{\n\tsize_t\thash;\n\n\thash = ((a * key + b) % p);\n\treturn (normalize(hash, size));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Dealloc",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/Dealloc/Dealloc.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "inline void\tdealloc_int(Generic addr)",
                                    "body": "{\n\tfree((int *)addr);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_uint64(Generic addr)",
                                    "body": "{\n\tfree((uint64_t *)addr);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tdealloc_float(Generic addr)",
                                    "body": "{\n\tfree((float *)addr);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tdealloc_string(Generic addr)",
                                    "body": "{\n\tfree((char *)addr);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tdealloc_long(Generic addr)",
                                    "body": "{\n\tfree((long long *)addr);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tdealloc_double(Generic addr)",
                                    "body": "{\n\tfree((double *)addr);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/MathUtils",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Utils/MathUtils/MathUtils.c",
                            "functions": []
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./DataStructures",
            "subfolders": [
                {
                    "name": "./DataStructures/Stack",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Stack/Stack.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "0\n\ninline Stack\tStack_Init(Generic value)",
                                    "body": "{\n\treturn (Stack)(LinkedList_Init(value));\n}"
                                },
                                {
                                    "doc": "/**\n * @brief adds a value on top of the stack\n *\n * @param stack\n * @param value\n */",
                                    "header": "inline void\tStack_Add(Stack stack, Generic value)",
                                    "body": "{\n\tLinkedList_Push((LinkedList *)&stack, value);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief removes the top value from the stack\n *\n * @param stack\n * @param dealloc\n * @note does not deallocate the value, call Stack_Dealloc_Element\n * @return Generic\n */",
                                    "header": "Generic\tStack_Poll(Stack *stack)",
                                    "body": "{\n\tGeneric\tout;\n\n\tif (!stack)\n\t\treturn (GENERIC_NULL);\n\tout = LinkedList_GetInfo(*stack);\n\t*stack = LinkedList_GetNext(*stack);\n\treturn (out);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief deallocates the stack element\n *\n * @param stack\n * @param dealloc\n */",
                                    "header": "void\tStack_Dealloc_Element(Stack stack, Deallocator dealloc)",
                                    "body": "{\n\tif (!stack)\n\t\treturn ;\n\tif (dealloc)\n\t\tdealloc(stack->info);\n\tfree(stack);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tStack_Free(Stack *stack, void (*dealloc)(Generic))",
                                    "body": "{\n\tLinkedList_Dealloc(*stack, dealloc);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Nodes",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Nodes/Nodes.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Node Node_Init(Generic info)",
                                    "body": "{\n\tNode node = Node_Allocate();\n\tif (!node)\n\t\treturn EmptyNode();\n\tnode->info = info;\n\tnode->next = EmptyNode();\n\treturn node;\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleNode DoubleNode_Init(Generic info)",
                                    "body": "{\n\tDoubleNode node = (DoubleNode)malloc(sizeof(DoubleNode_));\n\tif (!node)\n\t\treturn (DoubleNode)NULL;\n\tnode->info = info;\n\tnode->next = (DoubleNode)NULL;\n\tnode->prev = (DoubleNode)NULL;\n\treturn node;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Dictionary",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Dictionary/Dictionary.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "static Dict_obj\tDict_Obj_Init(Generic key, Generic value,\n\t\tDeallocator dealloc_key, Deallocator dealloc_value)",
                                    "body": "{\n\tDict_obj\tobj;\n\n\tobj = (Dict_obj)malloc(sizeof(t_dict_obj));\n\tif (!obj)\n\t\treturn (NULL);\n\tobj->key = key;\n\tobj->value = value;\n\tobj->dealloc_key = dealloc_key;\n\tobj->dealloc_value = dealloc_value;\n\treturn (obj);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "static void\tDict_Obj_Dealloc(Generic dict_obj)",
                                    "body": "{\n\tDict_obj\tobj;\n\n\tobj = (Dict_obj)dict_obj;\n\tif (obj->dealloc_key)\n\t\tobj->dealloc_key(obj->key);\n\tif (obj->dealloc_value)\n\t\tobj->dealloc_value(obj->value);\n\tfree(dict_obj);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "static size_t\thash_function(t_dict dict, size_t hashed_key)",
                                    "body": "{\n\treturn (hash_universal(hashed_key, dict->a, dict->b, dict->prime,\n\t\t\tdict->size));\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Adds object to dict without checking if key already exists\n * @note Used internally to avoid reallocating dict from zero\n */",
                                    "header": "static void\tsoft_add(t_dict dict, Dict_obj obj)",
                                    "body": "{\n\tsize_t\t\thash;\n\tLinkedList\tbucket;\n\n\thash = hash_function(dict, dict->hash_key(obj->key, dict->size));\n\tbucket = dict->buckets[hash];\n\tLinkedList_Push(&bucket, obj);\n\tdict->buckets[hash] = bucket;\n\tdict->used++;\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "static bool\tdict_has_breached_load_factor(t_dict dict)",
                                    "body": "{\n\treturn (((double)(dict->used + 1) / dict->size) >= MAX_LOAD_FACTOR);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Add value to dict\\r\n * @attention Key and value <= 8 bytes, use pointers for larger values\n *\n * @param dict\n * @param key value or address\n * @param value value or address\n * @param dealloc_value function to deallocate value\n * @return true if added, false if key already exists\n */",
                                    "header": "bool\tDict_Add(t_dict dict, Generic key, Generic value,\n\t\tDeallocator dealloc_value)",
                                    "body": "{\n\tsize_t\t\thash;\n\tLinkedList\t*buckets;\n\tDict_obj\tobj;\n\n\tif (!dict || Dict_Get(dict, key))\n\t\treturn (false);\n\tif (dict_has_breached_load_factor(dict))\n\t\tDict_Realloc(dict);\n\thash = hash_function(dict, dict->hash_key(key, dict->size));\n\tbuckets = dict->buckets;\n\tobj = Dict_Obj_Init(key, value, dict->dealloc_key, dealloc_value);\n\tif (!obj)\n\t\treturn (false);\n\tLinkedList_Push(buckets + hash, obj);\n\tdict->used++;\n\treturn (true);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Remove key and value from dict\n *\n * @param dict\n * @param key\n */",
                                    "header": "void\tDict_Remove(t_dict dict, Generic key)",
                                    "body": "{\n\tconst size_t\thash = hash_function(dict, dict->hash_key(key, dict->size));\n\tLinkedList\t\tbucket;\n\n\tbucket = (dict->buckets)[hash];\n\twhile (((Dict_obj)LinkedList_GetInfo(bucket))->key != key)\n\t\tbucket = LinkedList_GetNext(bucket);\n\tLinkedList_Remove(dict->buckets + hash, &Dict_Obj_Dealloc);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Graph",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Graph/Edge.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Edge\tEdge_Init(Vertex src, Vertex dest, uint64_t weight)",
                                    "body": "{\n\tEdge\tedge;\n\n\tedge = (Edge)malloc(sizeof(t_edge));\n\tif (!edge)\n\t\treturn (NULL);\n\tedge->src = src;\n\tedge->dest = dest;\n\tedge->weight = weight;\n\treturn (edge);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tEdge_Free(Generic edge)",
                                    "body": "{\n\tfree(edge);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/Graph/Explore.c",
                            "functions": []
                        },
                        {
                            "name": "./DataStructures/Graph/Graph_Ui.c",
                            "functions": []
                        },
                        {
                            "name": "./DataStructures/Graph/Pathfinding.c",
                            "functions": []
                        },
                        {
                            "name": "./DataStructures/Graph/Graph.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddVertex(Graph graph, Vertex vertex)",
                                    "body": "{\n\tLinkedList_Push(&graph->adjacency_list, vertex);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tLinkedList_Push(&vertex->edges, edge);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddDoubleEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tEdge\tdouble_edge;\n\n\tdouble_edge = Edge_Init(edge->dest, edge->src, edge->weight);\n\tGraph_AddEdge(vertex, edge);\n\tGraph_AddEdge(edge->dest, double_edge);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_RemoveDoubleEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tGraph_RemoveEdge(vertex, edge);\n\t// check if other edge exists\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/Graph/Vertex.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Vertex\tVertex_Init(Generic value)",
                                    "body": "{\n\tstatic uint32_t\tid = 0;\n\tVertex\t\t\tvertex;\n\n\tvertex = (Vertex)malloc(sizeof(t_vertex));\n\tif (!vertex)\n\t\treturn (NULL);\n\tvertex->edges = LINKEDLIST_EMPTY;\n\tvertex->value = value;\n\tvertex->id = id++;\n\tvertex->status = VERTEX_UNVISITED;\n\tvertex->distance = 0;\n\tvertex->discovery_time = 0;\n\tvertex->finish_time = 0;\n\tvertex->predecessor = NULL;\n\treturn (vertex);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVertex_Free(Graph graph, Vertex vertex)",
                                    "body": "{\n\tLinkedList_Dealloc(vertex->edges, Edge_Free);\n\tif (graph->dealloc_vertex)\n\t\tgraph->dealloc_vertex(vertex->value);\n\tfree(vertex);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/Graph/Utils.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "bool\tEdge_Relax(Vertex src, Vertex dest, uint64_t weight)",
                                    "body": "{\n\tif (dest->distance <= src->distance + weight)\n\t\treturn (false);\n\tdest->distance = src->distance + weight;\n\tdest->predecessor = src;\n\treturn (true);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tVertex_CmpDistance(Generic a, Generic b)",
                                    "body": "{\n\tuint64_t\t*dist_a;\n\tuint64_t\t*dist_b;\n\n\tdist_a = (uint64_t *)((t_heap_entry)a)->key;\n\tdist_b = (uint64_t *)((t_heap_entry)b)->key;\n\tif (*dist_a < *dist_b)\n\t\treturn (-1);\n\tif (*dist_a > *dist_b)\n\t\treturn (1);\n\treturn (0);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tVertex_CmpId(Generic a, Generic b)",
                                    "body": "{\n\treturn ((int)((Vertex)a)->id - (int)((Vertex)b)->id);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDijkstraHeapEntry_Free(Generic entry)",
                                    "body": "{\n\tt_heap_entry\te;\n\n\te = (t_heap_entry)entry;\n\tdealloc_uint64(e->key);\n\tfree(e);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tVertex_Hash(Generic vertex, size_t capacity)",
                                    "body": "{\n\treturn (((size_t)((Vertex)vertex)->id) % capacity);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Tree",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Tree/Bst.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "BST\tBst_Init(Generic key, Generic info, Comparator cmp)",
                                    "body": "{\n\tBST\tbst;\n\n\t(void)key;\n\tbst = (BST)malloc(sizeof(Bst));\n\tif (!bst)\n\t\treturn (NULL);\n\tbst->root = BinaryTree_Init(info, BINARY_TREE_EMPTY, BINARY_TREE_EMPTY);\n\tbst->cmp = cmp;\n\treturn (bst);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/Tree/BinaryTree.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "bool\tTreeIsEmpty(BinaryTree tree)",
                                    "body": "{\n\treturn (tree == NULL);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Init(Generic info, BinaryTree left, BinaryTree right)",
                                    "body": "{\n\tBinaryTree\ttree;\n\n\ttree = InitTreeNode();\n\tif (!tree)\n\t\treturn (BINARY_TREE_EMPTY);\n\ttree->info = info;\n\ttree->key = NULL;\n\ttree->left = left;\n\ttree->right = right;\n\treturn (tree);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Left(BinaryTree tree)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->left);\n\treturn (BINARY_TREE_EMPTY);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Right(BinaryTree tree)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->right);\n\treturn (BINARY_TREE_EMPTY);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tBinaryTree_Depth(BinaryTree tree)",
                                    "body": "{\n\tsize_t\tleft;\n\tsize_t\tright;\n\n\tif (TreeIsEmpty(tree))\n\t\treturn (0);\n\tleft = BinaryTree_Depth(BinaryTree_Left(tree));\n\tright = BinaryTree_Depth(BinaryTree_Right(tree));\n\treturn (1 + ((left > right) ? left : right));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline size_t\tBinaryTree_MaxNodesNumber(size_t depth)",
                                    "body": "{\n\treturn ((size_t)pow(2, depth) - 1);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Generic\tBinaryTree_Value(BinaryTree tree)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->info);\n\treturn (NULL);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_SetLeft(BinaryTree tree, BinaryTree left)",
                                    "body": "{\n\tif (!TreeIsEmpty(tree) && !TreeIsEmpty(left))\n\t\ttree->left = left;\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_SetDeepLeft(BinaryTree *tree, BinaryTree left)",
                                    "body": "{\n\tif (TreeIsEmpty(*tree))\n\t\t*tree = left;\n\telse\n\t\tBinaryTree_SetDeepLeft(&((*tree)->left), left);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tIsLeaf(BinaryTree tree)",
                                    "body": "{\n\treturn (TreeIsEmpty(BinaryTree_Left(tree))\n\t\t&& TreeIsEmpty(BinaryTree_Right(tree)));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tHasTwoNodes(BinaryTree tree)",
                                    "body": "{\n\treturn (!TreeIsEmpty(BinaryTree_Left(tree))\n\t\t&& !TreeIsEmpty(BinaryTree_Right(tree)));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_Free(BinaryTree tree)",
                                    "body": "{\n\tif (!tree)\n\t\treturn ;\n\t\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/PriorityQueue",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/PriorityQueue/PriorityQueue.c",
                            "functions": []
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Heap",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Heap/Heap.c",
                            "functions": [
                                {
                                    "doc": "/**\n * @brief swap entrie values\n */",
                                    "header": "static void\tswap_entries(t_heap_entry a, t_heap_entry b)",
                                    "body": "{\n\tGeneric\tkey;\n\tGeneric\tvalue;\n\n\tif (!a || !b)\n\t\treturn ;\n\tkey = a->key;\n\tvalue = a->value;\n\ta->key = b->key;\n\ta->value = b->value;\n\tb->key = key;\n\tb->value = value;\n}"
                                },
                                {
                                    "doc": "/**\n * @brief gets null terminated array length\n */",
                                    "header": "static size_t\tlimit_arr(t_heap_entry *arr, size_t expected_lenth)",
                                    "body": "{\n\tsize_t\ti;\n\n\tif (!arr || !expected_lenth)\n\t\treturn (0);\n\ti = 0;\n\twhile (i < expected_lenth && arr[i])\n\t\ti++;\n\treturn (i);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Heapify the heap at index i\n */",
                                    "header": "void\tHeap_Heapify(t_heap heap, size_t index)",
                                    "body": "{\n\tt_heap_entry\ttemp[3];\n\tt_heap_entry\tswap;\n\tsize_t\t\t\tmax_length;\n\n\tif (!heap || !heap->length)\n\t\treturn ;\n\ttemp[0] = heap->entries[index];\n\ttemp[1] = HeapEntry_GetLeftChild(heap, index);\n\ttemp[2] = HeapEntry_GetRightChild(heap, index);\n\tmax_length = limit_arr(temp, 3);\n\tif (!max_length)\n\t\treturn ;\n\tMergeSort((Generic *)temp, max_length, heap->cmp);\n\tif (heap->is_min_heap)\n\t\tswap = temp[0];\n\telse\n\t\tswap = temp[max_length - 1];\n\tif (swap->index == index)\n\t\treturn ;\n\tswap_entries(heap->entries[index], swap);\n\tHeap_Heapify(heap, swap->index);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief get min\n * @return actual value\n */",
                                    "header": "Generic\tHeap_GetMin(t_heap heap)",
                                    "body": "{\n\tif (!heap || !heap->is_min_heap)\n\t\treturn (NULL);\n\tif (heap->length == 0)\n\t\treturn (NULL);\n\treturn (heap->entries[0]->value);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief get max\n * @return actual value\n */",
                                    "header": "Generic\tHeap_GetMax(t_heap heap)",
                                    "body": "{\n\tif (!heap || heap->is_min_heap)\n\t\treturn (NULL);\n\tif (heap->length == 0)\n\t\treturn (NULL);\n\treturn (heap->entries[0]->value);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Poll the min value from the heap\n * @return the heap entry containing the min value\n */",
                                    "header": "t_heap_entry\tHeap_PollMin(t_heap heap)",
                                    "body": "{\n\tt_heap_entry\tmin;\n\n\tif (!heap || !heap->is_min_heap || !heap->length)\n\t\treturn (NULL);\n\tmin = heap->entries[0];\n\theap->entries[0] = heap->entries[heap->length - 1];\n\theap->length--;\n\tHeap_Heapify(heap, 0);\n\treturn (min);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Poll the max value from the heap\n * @return the heap entry containing the max value\n */",
                                    "header": "t_heap_entry\tHeap_PollMax(t_heap heap)",
                                    "body": "{\n\tt_heap_entry\tmax;\n\n\tif (!heap || heap->is_min_heap || !heap->length)\n\t\treturn (NULL);\n\tmax = heap->entries[0];\n\theap->entries[0] = heap->entries[heap->length - 1];\n\theap->length--;\n\tHeap_Heapify(heap, 0);\n\treturn (max);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Insert a new entry in the heap\n */",
                                    "header": "void\tHeap_Insert(t_heap heap, t_heap_entry entry)",
                                    "body": "{\n\tif (!heap || !entry || !entry->key)\n\t\treturn ;\n\tif (heap->length == heap->capacity)\n\t\treturn ;\n\tentry->index = heap->length;\n\theap->entries[heap->length] = entry;\n\theap->length++;\n\tif (heap->is_min_heap)\n\t\tHeap_Decrease(heap, heap->length - 1);\n\telse\n\t\tHeap_Increase(heap, heap->length - 1);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Replace the key of the entry in the heap\n */",
                                    "header": "void\tHeap_ReplaceKey(t_heap heap, t_heap_entry entry, Generic key,\n\t\tDeallocator dealloc)",
                                    "body": "{\n\tvoid\t(*func)(t_heap, size_t);\n\n\tif (!heap || !entry || !key)\n\t\treturn ;\n\tfunc = (heap->is_min_heap) ? Heap_Decrease : Heap_Increase;\n\tif (dealloc)\n\t\tdealloc(entry->key);\n\tentry->key = key;\n\tfunc(heap, entry->index);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/Heap/HeapEntry.c",
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Create a new heap entry.\n * @param key: the key of the entry\n * @param value: the value of the entry\n */",
                                    "header": "t_heap_entry\tHeapEntry_Init(Generic key, Generic value)",
                                    "body": "{\n\tt_heap_entry\tentry;\n\n\tentry = malloc(sizeof(t_heap_entry_));\n\tif (!entry)\n\t\treturn (NULL);\n\tentry->key = key;\n\tentry->value = value;\n\tentry->index = 0;\n\treturn (entry);\n}"
                                },
                                {
                                    "doc": "/**\n * @return the left child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetLeftChild(t_heap heap, size_t i)",
                                    "body": "{\n\tsize_t\tleft_child_index;\n\n\tleft_child_index = ENTRY_LEFT(i);\n\tif (left_child_index >= heap->length)\n\t\treturn (NULL);\n\treturn (heap->entries[left_child_index]);\n}"
                                },
                                {
                                    "doc": "/**\n * @return the right child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetRightChild(t_heap heap, size_t i)",
                                    "body": "{\n\tsize_t\tright_child_index;\n\n\tright_child_index = ENTRY_RIGHT(i);\n\tif (right_child_index >= heap->length)\n\t\treturn (NULL);\n\treturn (heap->entries[right_child_index]);\n}"
                                },
                                {
                                    "doc": "/**\n * @return the parent child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetParent(t_heap heap, size_t i)",
                                    "body": "{\n\tif (!i)\n\t\treturn (NULL);\n\treturn (heap->entries[ENTRY_PARENT(i)]);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Queue",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/Queue/Queue.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "0\n\ninline Queue\tQueue_Init(Generic info)",
                                    "body": "{\n\treturn (Queue)LinkedList_Init(info);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tQueue_Add(Queue *queue, Generic info)",
                                    "body": "{\n\tLinkedList_Append(queue, info);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Poll the first element of the queue\n * @param queue: the queue\n * @note element is not deallocated, call Queue_DeallocElement\n * @return the first element of the queue\n */",
                                    "header": "Queue\tQueue_poll(Queue *queue)",
                                    "body": "{\n\tQueue\tout;\n\n\tif (!queue || !*queue)\n\t\treturn (GENERIC_NULL);\n\tout = *queue;\n\t*queue = (*queue)->next;\n\treturn (out);\n}"
                                },
                                {
                                    "doc": "/**\n * @brief Deallocate the element of the queue\n * @param queue: the queue\n * @param dealloc: the deallocator function\n * @note use only if poll is called (dealloc poll returned value)\n */",
                                    "header": "void\tQueue_DeallocElement(Queue queue, Deallocator dealloc)",
                                    "body": "{\n\tif (!queue)\n\t\treturn ;\n\tif (dealloc)\n\t\tdealloc(queue->info);\n\tfree(queue);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline void\tQueue_Dealloc(Queue *queue, Deallocator dealloc)",
                                    "body": "{\n\tLinkedList_Dealloc(*queue, dealloc);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/LinkedList",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./DataStructures/LinkedList/DoubleLinkedList.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Init(Generic info)",
                                    "body": "{\n\treturn (DoubleNode_Init(info));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Insert(DoubleLinkedList *list,\n\t\tGeneric info, size_t index)",
                                    "body": "{\n\tDoubleLinkedList\ttemp;\n\tDoubleLinkedList\tnode;\n\tDoubleLinkedList\tprev;\n\n\tif (!list || !*list || !info)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\tif (index == START)\n\t\treturn (DoubleLinkedList_Push(list, info));\n\tif (index == LAST)\n\t\treturn (DoubleLinkedList_Append(*list, info));\n\ttemp = DoubleLinkedList_GetNth(*list, index);\n\tnode = DoubleNode_Init(info);\n\tif (temp)\n\t\ttemp->prev = node;\n\tnode->next = temp;\n\tprev = node->prev;\n\tnode->prev = prev;\n\tif (prev)\n\t\tprev->next = node;\n\treturn (node);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Append(DoubleLinkedList list, Generic info)",
                                    "body": "{\n\tDoubleLinkedList\tlast;\n\n\tlast = DoubleLinkedList_GetLast(list);\n\tlast->next = DoubleLinkedList_Init(info);\n\tlast->next->prev = last;\n\treturn (last->next);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Push(DoubleLinkedList *list, Generic info)",
                                    "body": "{\n\tDoubleLinkedList\tnode;\n\n\tnode = DoubleLinkedList_Init(info);\n\tnode->next = *list;\n\t*list = node;\n\treturn (node);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_Remove(DoubleLinkedList node, Deallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList\tnext;\n\tDoubleLinkedList\tprev;\n\n\tif (!node)\n\t\treturn ;\n\tnext = (node)->next;\n\tprev = (node)->prev;\n\tif (prev)\n\t\tprev->next = next;\n\tif (next)\n\t\tnext->prev = prev;\n\tif (dealloc)\n\t\tdealloc(node->info);\n\tfree(node);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_RemoveByValue(DoubleLinkedList list, Comparator cmp,\n\t\tGeneric info, Deallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList\tnode;\n\n\tnode = DoubleLinkedList_Search(list, cmp, info);\n\tDoubleLinkedList_Remove(node, dealloc);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_RemoveByIndex(DoubleLinkedList list, size_t index,\n\t\tDeallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList_Remove(DoubleLinkedList_GetNth(list, index), dealloc);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Search(DoubleLinkedList list,\n\t\tComparator cmp, Generic info)",
                                    "body": "{\n\twhile (list && cmp(DoubleLinkedList_GetInfo(list), info))\n\t\tlist = DoubleLinkedList_GetNext(list);\n\treturn (list);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetFirst(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetLast(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\twhile (list->next)\n\t\tlist = list->next;\n\treturn (list);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetNext(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->next);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetPrev(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->prev);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetInfo(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->next);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./DataStructures/LinkedList/LinkedList.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_Init(Generic value)",
                                    "body": "{\n\tLinkedList\tlist;\n\n\tlist = LinkedList_Alloc();\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\tlist->info = value;\n\tlist->next = LINKEDLIST_EMPTY;\n\treturn (list);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_Push(LinkedList *list, Generic object)",
                                    "body": "{\n\tLinkedList\tnode;\n\n\tnode = LinkedList_Init(object);\n\tnode->next = *list;\n\t*list = node;\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_Append(LinkedList *list, Generic value)",
                                    "body": "{\n\tLinkedList\tnode;\n\tLinkedList\tlast;\n\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\tnode = LinkedList_Init(value);\n\tlast = LinkedList_GetLast(*list);\n\tif (!last)\n\t\t*list = node;\n\telse\n\t\tlast->next = node;\n\treturn (node);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_Remove(LinkedList *node, Deallocator dealloc)",
                                    "body": "{\n\tLinkedList\ttmp;\n\n\tif (!node || !*node)\n\t\treturn ;\n\ttmp = *node;\n\t*node = (*node)->next;\n\tif (dealloc)\n\t\tdealloc(tmp->info);\n\tfree(tmp);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetNode(LinkedList list, Generic value)",
                                    "body": "{\n\tif (!list || !value)\n\t\treturn (LINKEDLIST_EMPTY);\n\twhile (LinkedList_GetInfo(list) != value)\n\t\tlist = LinkedList_GetNext(list);\n\treturn (list);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetNext(LinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\treturn (list->next);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Generic\tLinkedList_GetInfo(LinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (GENERIC_NULL);\n\treturn (list->info);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetLast(LinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\twhile (list->next)\n\t\tlist = list->next;\n\treturn (list);\n}"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./Algebra",
            "subfolders": [
                {
                    "name": "./Algebra/Complex",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Algebra/Complex/Complex.c",
                            "functions": [
                                {
                                    "doc": "/**\n * @brief \n */",
                                    "header": "t_complex\tComplex_Init(t_complex_type re, t_complex_type im)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = (t_complex)malloc(sizeof(t_complex_));\n\tif (!c)\n\t\treturn (NULL);\n\tc->re = re;\n\tc->im = im;\n\treturn (c);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tComplex_free(t_complex c)",
                                    "body": "{\n\tfree(c);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex_type\tComplex_mod(t_complex c)",
                                    "body": "{\n\tt_complex_type\tre;\n\tt_complex_type\tim;\n\n\tre = c->re;\n\tim = c->im;\n\treturn (sqrt(re * re + im * im));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_add(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = Complex_Init(a->re + b->re, a->im + b->im);\n\treturn (c);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_sub(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = Complex_Init(a->re - b->re, a->im - b->im);\n\treturn (c);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_mul(t_complex a, t_complex b)",
                                    "body": "{\n\treturn (Complex_Init(a->re * b->re - a->im * b->im, a->re * b->im + a->im\n\t\t\t* b->re));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_div(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex_type mod;\n\n\tmod = Complex_mod(b);\n\treturn (Complex_Init((a->re * b->re + a->im * b->im) / mod, (a->im * b->re\n\t\t\t\t- a->re * b->im) / mod));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Algebra/Matrix",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Algebra/Matrix/Matrix.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Init(size_t y, size_t x)",
                                    "body": "{\n\tMatrix\tmatrix;\n\n\tmatrix = (Matrix)malloc(sizeof(Mat));\n\tif (!matrix)\n\t\treturn (MATRIX_NULL);\n\tmatrix->table = InitTable(y, x);\n\tmatrix->cols = x;\n\tmatrix->rows = y;\n\treturn (matrix);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tIdentity_matrix(size_t length, Mat_type value)",
                                    "body": "{\n\tMatrix\tmatrix;\n\n\tmatrix = Matrix_Init(length, length);\n\tfor (size_t i = 0; i < length; i++)\n\t\tfor (size_t j = 0; j < length; j++)\n\t\t\tMatrix_SetValue(matrix, KroneckerDelta(i, j) * value, i, j);\n\treturn (matrix);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "inline bool\tKroneckerDelta(size_t i, size_t j)",
                                    "body": "{\n\treturn (i == j);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_SetValue(Matrix matrix, Mat_type value, size_t y, size_t x)",
                                    "body": "{\n\tif (!matrix)\n\t\treturn ;\n\tmatrix->table[y][x] = value;\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_ScalarProduct(Matrix mat, Mat_type scalar)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tnewMatrix = Matrix_Init(mat->rows, mat->cols);\n\tfor (size_t y = 0; y < mat->rows; y++)\n\t\tfor (size_t x = 0; x < mat->cols; x++)\n\t\t\tMatrix_SetValue(newMatrix, mat->table[y][x] * scalar, y, x);\n\treturn (newMatrix);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Transpose(Matrix mat)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tif (!mat)\n\t\treturn (MATRIX_NULL);\n\tnewMatrix = Matrix_Init(mat->cols, mat->rows);\n\tfor (size_t row = 0; row < mat->rows; row++)\n\t\tfor (size_t col = 0; col < mat->cols; col++)\n\t\t\tMatrix_SetValue(newMatrix, mat->table[row][col], col, row);\n\treturn (newMatrix);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_Free(Matrix matrix)",
                                    "body": "{\n\tfor (size_t i = 0; i < matrix->rows; i++)\n\t\tfree(matrix->table[i]);\n\tfree(matrix->table);\n\tfree(matrix);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Mat_type\tMatrix_GetValue(Matrix matrix, size_t y, size_t x)",
                                    "body": "{\n\treturn (matrix->table[y][x]);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Algebra/Vector",
                    "subfolders": [],
                    "files": [
                        {
                            "name": "./Algebra/Vector/UVector2.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "t_uvector2\tUVector2_init(uint64_t x, uint64_t y)",
                                    "body": "{\n\tt_uvector2\tvector;\n\n\tvector = malloc(sizeof(t_uvector2_));\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\treturn (vector);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tUVector2_free(t_uvector2 vector)",
                                    "body": "{\n\tif (!vector)\n\t\treturn ;\n\tfree(vector);\n}"
                                }
                            ]
                        },
                        {
                            "name": "./Algebra/Vector/Vector.c",
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_init(VectorType x, VectorType y)",
                                    "body": "{\n\tVector2\tvector;\n\n\tvector = AllocateVector2();\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\treturn (vector);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_init(VectorType x, VectorType y, VectorType z)",
                                    "body": "{\n\tVector3\tvector;\n\n\tvector = AllocateVector3();\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\tvector->z = z;\n\treturn (vector);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Sum(Vector2 v, Vector2 v2)",
                                    "body": "{\n\treturn (Vector2_init(v->x + v2->x, v->y + v2->y));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Sum(Vector3 v, Vector3 v2)",
                                    "body": "{\n\treturn (Vector3_init(v->x + v2->x, v->y + v2->y, v->z + v2->z));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Mul(VectorType num, Vector2 v)",
                                    "body": "{\n\treturn (Vector2_init(num * (v->x), num * (v->y)));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Mul(VectorType num, Vector3 v)",
                                    "body": "{\n\treturn (Vector3_init(v->x *= num, v->y *= num, v->z *= num));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector2_ScalarProduct(Vector2 v, Vector2 v2)",
                                    "body": "{\n\treturn (v->x * v2->x + v2->y * v2->y);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector3_ScalarProduct(Vector3 v, Vector3 v2)",
                                    "body": "{\n\treturn (v->x * v2->x + v2->y * v2->y + v->z * v2->z);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_VectorialProduct(Vector3 v, Vector3 v2)",
                                    "body": "{\n\treturn (Vector3_init(v->y * v2->z + v->z * v2->y, v->z * v2->x + v->x\n\t\t\t* v2->z, v->x * v2->y + v->y * v2->x));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector2_Module(Vector2 v)",
                                    "body": "{\n\treturn (sqrt(pow(v->x, 2) + pow(v->y, 2)));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector3_Module(Vector3 v)",
                                    "body": "{\n\treturn (sqrt(pow(v->x, 2) + pow(v->y, 2) + pow(v->z, 2)));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Normalized(Vector2 v)",
                                    "body": "{\n\tconst VectorType\tmodule = Vector2_Module(v);\n\n\treturn (Vector2_init(v->x / module, v->y / module));\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Normalized(Vector3 v)",
                                    "body": "{\n\tconst VectorType\tmodule = Vector3_Module(v);\n\n\treturn Vector3_init(v->x / module, v->y / module, v->z / module);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector2_Print(Vector2 v)",
                                    "body": "{\n\tprintf(\"Vector:\\nx: %lf y: %lf\\n\", v->x, v->y);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector3_Print(Vector3 v)",
                                    "body": "{\n\tprintf(\"Vector:\\nx: %lf y: %lf z: %lf\\n\", v->x, v->y, v->z);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector2_Free(Vector2 v)",
                                    "body": "{\n\tfree(v);\n}"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector3_Free(Vector3 v)",
                                    "body": "{\n\tfree(v);\n}"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        }
    ],
    "files": []
}